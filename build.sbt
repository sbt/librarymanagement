import Dependencies._
import Path._

// import com.typesafe.tools.mima.core._, ProblemFilters._

def baseVersion = "1.0.0"

def commonSettings: Seq[Setting[_]] = Seq(
  scalaVersion := scala212,
  // publishArtifact in packageDoc := false,
  resolvers += Resolver.typesafeIvyRepo("releases"),
  resolvers += Resolver.sonatypeRepo("snapshots"),
  resolvers += "bintray-sbt-maven-releases" at "https://dl.bintray.com/sbt/maven-releases/",
  // concurrentRestrictions in Global += Util.testExclusiveRestriction,
  testOptions += Tests.Argument(TestFrameworks.ScalaCheck, "-w", "1"),
  javacOptions in compile ++= Seq("-Xlint", "-Xlint:-serial"),
  crossScalaVersions := Seq(scala211, scala212),
  resolvers += Resolver.sonatypeRepo("public"),
  scalacOptions := {
    val old = scalacOptions.value
    scalaVersion.value match {
      case sv if sv.startsWith("2.10") => old diff List("-Xfuture", "-Ywarn-unused", "-Ywarn-unused-import")
      case sv if sv.startsWith("2.11") => old ++ List("-Ywarn-unused", "-Ywarn-unused-import")
      case _                           => old ++ List("-Ywarn-unused", "-Ywarn-unused-import", "-YdisableFlatCpCaching")
    }
  },
  // mimaPreviousArtifacts := Set(), // Some(organization.value %% moduleName.value % "1.0.0"),
  publishArtifact in Compile := true,
  publishArtifact in Test := false,
  parallelExecution in Test := false
)

lazy val lmRoot = (project in file("."))
  .aggregate(utilInterface, utilPosition, utilShowLines, utilLogging, utilCache, lm)
  .settings(
    inThisBuild(
      Seq(
        homepage := Some(url("https://github.com/sbt/librarymanagement")),
        description := "Library management module for sbt",
        scmInfo := Some(ScmInfo(
          url("https://github.com/sbt/librarymanagement"), "git@github.com:sbt/librarymanagement.git"
        )),
        bintrayPackage := "librarymanagement",
        scalafmtOnCompile := true,
        // scalafmtVersion 1.0.0-RC3 has regression
        scalafmtVersion := "0.6.8",
        git.baseVersion := baseVersion
      )),
    commonSettings,
    name := "LM Root",
    publish := {},
    publishLocal := {},
    publishArtifact in Compile := false,
    publishArtifact := false,
    customCommands
  )

val javaOnlySettings: Seq[Setting[_]] = Seq(
  crossPaths := false,
  compileOrder := CompileOrder.JavaThenScala,
  unmanagedSourceDirectories in Compile := Seq((javaSource in Compile).value),
  crossScalaVersions := Seq(scala211),
  autoScalaLibrary := false
)

// defines Java structures used across Scala versions, such as the API structures and relationships extracted by
//   the analysis compiler phases and passed back to sbt.  The API structures are defined in a simple
//   format from which Java sources are generated by the datatype generator Projproject
val utilInterface = project in file("internal") / "util-interface" settings (
  commonSettings,
  javaOnlySettings,
  name := "Util Interface",
  exportJars := true
)

val utilPosition = project in file("internal") / "util-position" settings (
  commonSettings,
  name := "Util Position"
)

val utilShowLines = project in file("internal") / "util-showlines" settings (
  commonSettings,
  name := "Util ShowLines"
)

// logging
lazy val utilLogging = (project in file("internal") / "util-logging")
  .enablePlugins(ContrabandPlugin, JsonCodecPlugin)
  .dependsOn(utilInterface, utilShowLines)
  .settings(
    commonSettings,
    crossScalaVersions := Seq(scala210, scala211, scala212),
    name := "Util Logging",
    libraryDependencies ++= Seq(
      jline, log4jApi, log4jCore, disruptor, sjsonnewScalaJson, scalaReflect.value, scalaTest, scalaCheck
    ),
    sourceManaged in (Compile, generateContrabands) := baseDirectory.value / "src" / "main" / "contraband-scala"
  )
  .configure(addSbtIO)

// Persisted caching based on sjson-new
lazy val utilCache = (project in file("util-cache"))
  .settings(
    commonSettings,
    name := "Util Cache",
    libraryDependencies ++= Seq(sjsonnewScalaJson, scalaReflect.value, scalaTest)
  )
  .configure(addSbtIO)

lazy val lm = (project in file("librarymanagement"))
  .settings(
    commonSettings,
    name := "librarymanagement",
    libraryDependencies ++= Seq(
      ivy, jsch, scalaReflect.value, launcherInterface, gigahorseOkhttp, okhttpUrlconnection,
      sjsonnewScalaJson % Optional,
      scalaTest
    ),
    libraryDependencies ++= scalaXml.value,
    resourceGenerators in Compile += Def.task(
      Util.generateVersionFile(
        version.value, resourceManaged.value, streams.value, (compile in Compile).value
      )
    ).taskValue,
    // mimaBinaryIssueFilters ++= Seq(),
    contrabandFormatsForType in generateContrabands in Compile := DatatypeConfig.getFormats,
    // WORKAROUND sbt/sbt#2205 include managed sources in packageSrc
    mappings in (Compile, packageSrc) ++= {
      val srcs = (managedSources in Compile).value
      val sdirs = (managedSourceDirectories in Compile).value
      val base = baseDirectory.value
      (((srcs --- sdirs --- base) pair (relativeTo(sdirs) | relativeTo(base) | flat)) toSeq)
    }
  )
  .dependsOn(utilPosition, utilLogging, utilCache)
  .configure(addSbtIO)
  .enablePlugins(ContrabandPlugin, JsonCodecPlugin)

def customCommands: Seq[Setting[_]] = Seq(
  commands += Command.command("release") { state =>
    // "clean" ::
    "so compile" ::
      "so publishSigned" ::
      "reload" ::
      state
  }
)
